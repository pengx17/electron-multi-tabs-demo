import { ipcRenderer } from "electron";
import type { handlers } from "../main/handlers";

type WithoutFirstParameter<T> = T extends (_: any, ...args: infer P) => infer R
  ? (...args: P) => R
  : T;

type HandlersMap<N extends keyof typeof handlers> = {
  [K in keyof (typeof handlers)[N]]: WithoutFirstParameter<
    (typeof handlers)[N][K]
  >;
};

type Handlers = {
  [N in keyof typeof handlers]: HandlersMap<N>;
};

export const apis: Handlers = (() => {
  // the following were generated by the build script
  // 1. bundle extra main/src/handlers.ts entry
  // 2. use generate-handlers-meta.mjs to generate handlers-meta.js in dist
  //
  // we cannot directly import main/src/handlers.ts because it will be bundled into the preload bundle
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const handlersMeta: [string, string[]][] = require('../main/handlers-meta');

  const all = handlersMeta.map(([namespace, functionNames]) => {
    const namespaceApis = functionNames.map(name => {
      const channel = `${namespace}:${name}`;
      return [
        name,
        (...args: any[]) => {
          console.log('Invoke handler', channel, 'with args:', args);
          return ipcRenderer.invoke(channel, ...args);
        },
      ];
    });
    return [namespace, Object.fromEntries(namespaceApis)];
  });

  return Object.fromEntries(all);
})();

export const events = {
  onTabsUpdated: (callback: (tabs: string[]) => void) => {
    ipcRenderer.on("onTabsUpdated", (_, tabs) => {
      callback(tabs);
    });
  },
  onActiveTabChanged: (callback: (tab: string) => void) => {
    ipcRenderer.on("onActiveTabChanged", (_, tab) => {
      callback(tab);
    });
  },
};

export const appInfo = {
  id: process.argv.find((arg) => arg.startsWith("--id="))?.split("=")[1],
};
